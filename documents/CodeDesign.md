<h2 id="94uay">Map of the level</h2>
Here is the map design of level 3 in my game. The graph below shows the overall map of 2d top-down view:

![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683818491-c7761edc-11d8-47d1-9864-54c81d6d50f1.png)

Here is the legend of the map:

![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683818735-eaab0ecc-5095-4a83-98e6-7641e14ba031.png)

![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683819011-03c8f80d-d233-4802-960c-de3cefbb7f84.png)The following figures show the process of finishing level 3.

The player can eat the HP bean to improve the HP. 







![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683819271-47caea26-9f12-4f65-b84b-dc9cc108bdf2.png)After eating two HP beans, the player can get the sword to improve the attacking power. Here, the total attacking power is the players basic attacking power plus the weapon’s attacking power. The basic attacking power is related to the player HP.  



![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683819541-61600be2-c331-4118-b365-ad2502cdef2e.png)![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683819734-13612e7a-6bb7-4701-8dc7-6084f4bb006b.png)Here, the player can kill the enemy, if the total attacking power of the player is greater the enemy’s attacking power. If player kill the enemy, the player will earn EXP (experience), which will improve player’s HP. Here, the player's HP will increase each time their experience points (XP) reach a certain amount.

Here, the player can switch their weapon with higher attacking power. 

















![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683819962-a377dd95-c142-44bf-8d00-f67bed3e025f.png)Here, the player needs to kill the enemy to get the key to the exit door of the maze. 









![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683820213-fbb6840a-6130-4d6a-94a4-ae642d4c6b3c.png)After getting key, the player meets an enemy that can be triggered to chase player. The box around the enemy is the range that if player enter this range, the enemy will chase the player endlessly. The player can choose to get away from enemy, or player can also kill the enemy with higher attacking power. 

![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683820492-79c53b70-954e-44fa-b214-df87185a394e.png)

Assume player choose to get away from enemy. The player move to the exit door of the maze. The player use the key to open the door, and finally successfully finish this level and move to next level. 





![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683820762-3d30f7d9-561c-42ee-ba64-0895a409a4a1.png)![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683821001-5ae1b64c-d1f0-4cce-8e8f-beab3e09cda6.png)![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683821260-470d686e-886f-491f-97c5-4bfe8a0e4661.png)![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683821451-f3d54c7e-eae6-4994-a539-932ce0fec7be.png)![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683821709-b5b1cd64-c1df-486c-953e-1aba0a1541d5.png)![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683821933-227d6c8c-5385-4788-a517-41804d72e9ca.png)![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683822147-44ba5ada-11c8-4deb-af6e-1c7eca334a40.png)![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683822374-b165170b-516d-403b-8c9d-9af504d7db1a.png)**Sources of texture used on the map: **



![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683822618-83eeed08-3300-4759-baff-ad8b2655198e.png)![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683822768-ac144379-8aca-4fe5-9e26-99c5c0e810e2.png)These textures above are generated by Chatgpt-4o, the prompt it used to generate these textures are declared in the AI declaration later. 



These textures above are downloaded from website [https://www.aigei.com/game/](https://www.aigei.com/game/). The game's website assets, including textures, are open-source.![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683822949-715d6058-f089-4123-8a2e-aeb3df824eee.png)![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683823163-a9c5b61c-aa4d-4770-86e0-80fabcc80016.png)



<h2 id="ebjfm">Flow Chart of representative level</h2>
![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683823375-e283584e-8fae-40d8-aaa2-607a408770a0.png)The flow chart of representative level is shown on the right side of this page.

The legend of this game flow chart:

![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683823626-79b4923b-5580-4e70-8376-faa43986314e.png)

![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683823796-a326d8a4-834f-4a25-a12a-033ecd87176c.png)

![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683823928-d708cdbd-a5fe-485f-b00a-16aedb60cd28.png)

![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683824089-280dfd6e-e7a8-44fc-9c22-b30d1ce5a120.png)



<h2 id="LE0oN">Architecture of the game</h2>
This code design plans to use godot engine to develop this game.

**The godot node tree design of the game:**

![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683824250-683374c2-7380-4e9b-9e6f-1a46be4d7cac.png)

**The UML class diagram**. The UML class diagram is shown as below:

![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683824468-040a8830-3885-49e8-9214-6853c1ebe891.png)![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683824672-4e4b9b19-5694-4b8b-8f74-12cc0f1b214c.png)

Here in the UML class diagram, there are several design patterns used:

1. Singleton Pattern. The place it is used in diagram is shown in the right. The GameManager class is designed as a singleton (explicitly marked with the <<singleton>> stereotype in the class diagram).



![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683824908-9c149319-05f3-45e1-8ddd-69b974a143db.png)2. Observation pattern. This project adopts the Observer Pattern, utilizing Godot’s built-in signal system to enable decoupled communication between components. Several classes act as “subjects” (such as Player, EnemyBase, ItemBase, Door, and GameManager), emitting signals when their state changes or specific events occur. Other classes (such as GUI, Player, and GameManager) serve as “observers,” listening to these signals and responding accordingly. The place it uses Observation Pattern is shown on the right side.

![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683825101-762fc669-bbe2-44d6-aa1e-9a9f74971147.png)

3. This project uses the State Pattern to manage enemy AI behavior. Each enemy has a state machine (e.g., EnemyStateMachine) that executes different logic based on its current state. The behavior for each state is encapsulated in separate classes, and state transitions are handled through the enter(), exit(), and update() methods. This design keeps the enemy AI structure clear, modular, and easy to extend or maintain, avoiding complex conditional logic. The place it uses observation pattern is shown on the right side. 





**The signal flow of this game design is shown as below:**

![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683825294-22ed0b4b-635e-4b3f-8400-b7cafa993a43.png)



<h2 id="rZur0">Techniques I Plan to Use</h2>
To satisfy requirement 3, I plan to use recursive backtracking in procedural level generation and use A* and FSM in enemy AI.

**Procedural Level Generation (PCG)**

For procedurally generating maze-based levels, I plan to utilize recursive backtracking technique. Recursive backtracking algorithm creates solvable mazes through a systematic process of visiting unexplored cells and backtracking when reaching dead ends. It typically initiates from a randomly selected cell, marks it as visited, and then recursively explores adjacent unvisited cells. When encountering a cell with no unvisited neighbors, the algorithm backtracks to the previous position to explore alternative paths. This methodical exploration continues until every accessible cell has been visited [1]. Building upon this algorithm, I will enhance the maze design by strategically placing enemies, items, and locked doors throughout the structure. This approach ensures levels remain solvable while enriching the gameplay experience with meaningful challenges and diverse exploration opportunities. 

This methodology guarantees fully connected and completable levels that can be scaled in difficulty by increasing maze depth, key requirements, or enemy presence [2]. In this game development, implementation of a seeded random number generator will provide reproducible level creation, facilitating consistent testing scenarios. Level generation will be executed prior to gameplay commencement, with the constructed environments rendered via Godot's TileMap system.

Instead of developing the algorithm from the ground up, I will modify established pseudocode to accommodate my custom grid structure. The algorithm's strength lies in its efficient stack-based or recursive navigation and methodical creation of passages through wall removal between current cells and their unvisited neighbors. My implementation will prioritize seamless integration between the maze generation process and Godot's level loading framework, while carefully positioning player spawn locations, doors, and keys to satisfy essential gameplay requirements.

**Enemy Artificial Intelligence**

I will implement basic AI for enemy behavior using finite state machines (FSM). This framework will manage enemy states including:

• Idle: maintaining position until triggered 

• Chase: pursuing the player upon line-of-sight detection 

• Attack: inflicting damage when within striking distance 

• Dead: removing the entity from gameplay while rewarding player experience

Each state will feature defined transition triggers and action patterns, delivering consistent yet compelling enemy encounters. The FSM approach offers precise behavioral control while remaining straightforward to implement, making it ideally suited for both this project's scope and its assessment criteria [3].

To manage enemy movement, I will utilize Godot's integrated Navigation2D and A* pathfinding system, allowing enemies to effectively navigate obstacles and track the player through dynamically generated paths [4]. The A* algorithm is renowned for its performance and path optimality, utilizing heuristic functions (like Euclidean or Manhattan distance) to guide search efforts toward targets while considering actual movement costs. This algorithm effectively balances path expense evaluation with distance estimation, making it perfect for enemies needing to navigate maze structures to reach the player [7]. Rather than coding A* manually, I'll implement the NavigationAgent2D component, configure appropriate navigation meshes, and establish collision avoidance parameters to prevent enemies from clustering in narrow corridors.

**Alternative techniques I considered**

When considering alternatives for procedural level generation, I evaluated random tile placement with subsequent solvability verification. Though implementation is straightforward, this approach proves highly inefficient as most randomly generated configurations are unsolvable, requiring multiple regeneration attempts. Furthermore, such methods typically produce levels lacking structured design and consistent gameplay flow [5]. I also examined cellular automata techniques, which generate organic, cave-like environments with natural-appearing formations. Despite their aesthetic advantages, levels created through cellular automata present considerable challenges in ensuring completability, particularly within constrained spatial dimensions [6].

In my evaluation of enemy AI approaches, I considered several alternatives before finalizing my decision. For pathfinding solutions, flow field systems offer advantages when numerous units share common destinations, but their reduced precision and slow adaptation to dynamic map alterations make them less suitable for maze environments [8]. While conceptually straightforward, Dijkstra's algorithm lacks the heuristic optimization of A*, resulting in inferior performance for our needs [9]. Regarding behavior management, Behavior Trees would enable more sophisticated decision processes but introduce unnecessary complexity given our project parameters [10]. Likewise, Utility AI delivers powerful dynamic decision capabilities but requires extensive tuning and substantially increases development overhead [11]. Though these alternatives excel in certain contexts, they present disadvantages in implementation efficiency and assessment clarity that make the A* and FSM combination optimal for this specific project.

**References:**

[1]A. Karlsson, ‘Evaluation of the Complexity of Procedurally Generated Maze Algorithms’, Dissertation, 2018. Available: [https://www.diva-portal.org/smash/record.jsf?pid=diva2%3A1237178&dswid=5689](https://www.diva-portal.org/smash/record.jsf?pid=diva2%3A1237178&dswid=5689)

[2]<font style="color:#333333;"> </font>J. Vijaya, A. Gopu, K. V. S. G. Vinayak, T. J. Singh and K. Malhotra, "Analysis of Maze Generation Algorithms," _2024 5th International Conference on Innovative Trends in Information Technology (ICITIIT)_, Kottayam, India, 2024, pp. 1-6, doi: [https://doi.org/10.1109/ICITIIT61487.2024.10580178](https://doi.org/10.1109/ICITIIT61487.2024.10580178).

[3] Coding Quests, " Finite State Machines Explained In Less Than 10 Minutes" YouTube, Aug. 13, 2024. [Online]. Available: [https://www.youtube.com/watch?v=sNFMdLEVxFo](https://www.youtube.com/watch?v=sNFMdLEVxFo)

[4]Godot Engine, "2D navigation overview," _Godot Documentation_. [Online]. Available: [https://docs.godotengine.org/en/stable/tutorials/navigation/navigation_introduction_2d.html](https://docs.godotengine.org/en/stable/tutorials/navigation/navigation_introduction_2d.html). [Accessed: May 14, 2025]

[5]<font style="color:#222222;"> </font>Yannakakis, G.N., Togelius, J. (2018). Generating Content. In: Artificial Intelligence and Games. Springer, Cham. [https://doi.org/10.1007/978-3-319-63519-4_4](https://doi.org/10.1007/978-3-319-63519-4_4).

[6]<font style="color:#333333;"> </font>Lawrence Johnson, Georgios N. Yannakakis, and Julian Togelius. 2010. Cellular automata for real-time generation of infinite cave levels. In Proceedings of the 2010 Workshop on Procedural Content Generation in Games (PCGames '10). Association for Computing Machinery, New York, NY, USA, Article 10, 1–4. [https://doi.org/10.1145/1814256.1814266](https://doi.org/10.1145/1814256.1814266).

[7]<font style="color:#222222;"> </font>Cui, Xiao, and Hao Shi. "A*-based pathfinding in modern computer games." _International Journal of Computer Science and Network Security_ 11.1 (2011): 125-130. Available: [https://www.researchgate.net/profile/Xiao-Cui-12/publication/267809499_A-based_Pathfinding_in_Modern_Computer_Games/links/54fd73740cf270426d125adc/A-based-Pathfinding-in-Modern-Computer-Games.pdf](https://www.researchgate.net/profile/Xiao-Cui-12/publication/267809499_A-based_Pathfinding_in_Modern_Computer_Games/links/54fd73740cf270426d125adc/A-based-Pathfinding-in-Modern-Computer-Games.pdf)

[8]<font style="color:#222222;"> </font>Emerson, Elijah. "Crowd pathfinding and steering using flow field tiles." _Game AI Pro 360: Guide to Movement and Pathfinding_. CRC Press, 2019. 67-76. Available: [https://www.taylorfrancis.com/chapters/edit/10.1201/9780429055096-7/crowd-pathfinding-steering-using-flow-field-tiles-elijah-emerson](https://www.taylorfrancis.com/chapters/edit/10.1201/9780429055096-7/crowd-pathfinding-steering-using-flow-field-tiles-elijah-emerson)

[9]<font style="color:#333333;"> </font>N. O. Eraghi, F. López-Colino, A. de Castro and J. Garrido, "Path length comparison in grid maps of planning algorithms: HCTNav, A* and Dijkstra," _Design of Circuits and Integrated Systems_, Madrid, Spain, 2014, pp. 1-6, doi: 10.1109/DCIS.2014.7035557.

[10]<font style="color:#222222;"> </font>Iovino, Matteo, et al. "A survey of behavior trees in robotics and ai." _Robotics and Autonomous Systems_ 154 (2022): 104096. doi: [https://doi.org/10.1016/j.robot.2022.104096](https://doi.org/10.1016/j.robot.2022.104096).

[11] Dill, Kevin, et al. "Design patterns for the configuration of utility-based AI." _Interservice/Industry Training, Simulation, and Education Conference (I/ITSEC)_. Vol. 2012. 2012. Available: [https://course.khoury.northeastern.edu/cs5150f13/readings/dill_designpatterns.pdf](https://course.khoury.northeastern.edu/cs5150f13/readings/dill_designpatterns.pdf)



<h2 id="THWq1">AI Declaration</h2>
<h3 id="NGxUG">Statement of acknowledgement</h3>
Please include the statement that reflects how you have used any GAI tools from one of the following:

+ I acknowledge the use of [Chatgpt-4o] to generate materials for background research and self-study in the drafting of this assessment. 
+ I acknowledge the use of [Chatgpt-4o] to generate materials that were included within my final assessment in modified form. 
+ I acknowledge the use of [Chatgpt-4o] to generate materials that were included in my final assessment in unmodified form. (An example of this would be a quote or image produced by the AI output.)

<h3 id="1lW5u">Description of how information or material was generated</h3>
You must describe how the information or material was generated, what the output was and how the output was modified by you using the following format: 

+ The following prompts were input into [Chatgpt-4o: { What is the purpose of the TileMap node in the Godot engine, and how does it relate to level design in 2D games?}] 
+ The output obtained was: [The TileMap node in the Godot Engine is used to create grid-based 2D levels efficiently by placing and managing tiles from a predefined tileset. It allows developers to design maps using reusable visual components while maintaining precise collision, navigation, and performance optimizations.

In 2D games, TileMap plays a central role in level design, as it abstracts away manual placement of sprites and ensures alignment within a fixed grid. Tiles can be used to represent floors, walls, obstacles, or interactive elements like traps and doors. Godot also supports layers, auto-tiling, and tile-based navigation, making TileMap ideal for maze games, platformers, and tactical RPGs.

By leveraging TileMap, designers can focus on layout and gameplay logic, while benefiting from Godot’s built-in rendering, collision, and pathfinding systems tailored to tile-based worlds.] 

+ The output was changed and adapted by me in the following ways: [I gain the ideas of TileMap node in godot engine focusing on maze generation, which helps me to design the class diagram of game design.]



+ The following prompts were input into [Chatgpt-4o: {Explain how the recursive backtracking algorithm is used to generate mazes in 2D grid-based games.}] 
+ The output obtained was: [Recursive backtracking is a depth-first maze generation algorithm commonly used in grid-based games. It begins at a starting cell, marks it as visited, and randomly selects a neighbor to move to, carving a path and repeating the process. When a cell has no unvisited neighbors, the algorithm backtracks to the previous cell and continues. This continues until all reachable cells are visited, resulting in a fully connected, solvable maze. The algorithm produces mazes with long winding passages and few loops, making it ideal for puzzle-style gameplay. It can be implemented recursively or using a manual stack to simulate the call stack.]
+ The output was changed and adapted by me in the following ways: [I rewrote the explanation using a more formal and technical tone to better fit my academic report. I removed descriptive phrases such as "long winding passages" and subjective language like "ideal for puzzle-style gameplay" to make the explanation more concise and objective. I restructured the paragraph to emphasize the systematic nature of the algorithm, and focused more directly on the core mechanism of visiting unvisited cells and backtracking. I also eliminated implementation details (like stack simulation) to keep the explanation focused on conceptual understanding relevant to my use in Part 4]



+ The following prompts were input into [Chatgpt-4o: { Then please generate monster textures according to the game description. There are monsters with small, medium and large combat power values. The appearance of these three monsters should be significantly different and can intuitively reflect their combat power values.}
+ ![](https://cdn.nlark.com/yuque/0/2025/png/38635443/1748683825660-06317792-cbf0-49d8-801d-816cd31d2091.png)The output obtained was: [ 











]

+ The output was changed and adapted by me in the following ways: [I directly take a snapshot of the graph Chatgpt-4o generated, use it in the map design in the report.]



