# Player.gd 重构说明

## 重构概述

已将 `Player.gd` 中的背包与武器管理相关逻辑提取到独立的系统脚本中，实现了更好的代码组织和职责分离。

## 新的系统架构

### 1. InventorySystem.gd (背包系统)
位置：`scripts/InventorySystem.gd`

**职责：**
- 管理钥匙的添加、使用和查询
- 记录HP豆的消费数量
- 发送背包变化相关信号

**主要功能：**
```gdscript
# 钥匙管理
add_key(key_type: String) -> bool
has_key(key_type: String) -> bool
use_key(key_type: String) -> bool
get_keys() -> Array[String]

# HP豆管理
consume_hp_bean()
get_hp_beans_consumed() -> int

# 调试
print_inventory_status()
```

**信号：**
- `inventory_changed` - 背包内容发生变化时触发
- `key_added(key_type: String)` - 获得新钥匙时触发
- `key_used(key_type: String)` - 使用钥匙时触发

### 2. WeaponSystem.gd (武器系统)
位置：`scripts/WeaponSystem.gd`

**职责：**
- 管理武器的获得、切换和查询
- 处理武器相关的用户输入
- 维护当前装备的武器状态

**主要功能：**
```gdscript
# 武器获取
try_equip_weapon(weapon_id: String, weapon_name: String, weapon_attack: int) -> bool

# 武器切换
switch_to_next_weapon()
switch_to_previous_weapon()
switch_to_weapon_by_index(index: int)

# 输入处理
handle_weapon_input()

# 查询功能
get_available_weapons() -> Array[WeaponData]
get_current_weapon() -> WeaponData
get_current_weapon_index() -> int
get_weapon_count() -> int
get_weapon_attack_power() -> int
```

**信号：**
- `weapon_changed(current_weapon: WeaponData)` - 当前武器改变时触发
- `weapon_acquired(weapon: WeaponData)` - 获得新武器时触发
- `weapon_switched(from_index: int, to_index: int)` - 武器切换时触发

### 3. Player.gd (简化后的玩家脚本)
**主要职责：**
- 移动和状态机管理
- 攻击逻辑和动画控制
- 生命值管理
- 作为系统间的协调者

**系统组件引用：**
```gdscript
var inventory_system: InventorySystem
var weapon_system: WeaponSystem

# 系统在_ready()函数中动态创建和初始化
func _initialize_systems():
    inventory_system = InventorySystem.new()
    weapon_system = WeaponSystem.new()
    add_child(inventory_system)
    add_child(weapon_system)
```

## 向后兼容性

为了确保现有代码的正常运行，Player.gd 保留了所有原有的公共接口函数，这些函数现在作为适配器委托给相应的系统：

```gdscript
# 向后兼容的武器接口
func try_equip_weapon(weapon_id: String, weapon_name: String, weapon_attack: int) -> bool
func switch_to_next_weapon()
func get_current_weapon() -> WeaponData
# ... 等等

# 向后兼容的背包接口
func add_key(key_type: String)
func has_key(key_type: String) -> bool
func use_key(key_type: String) -> bool
func get_keys() -> Array[String]
```

## 使用示例

### 在其他脚本中访问系统

```gdscript
# 获取玩家引用
var player = get_tree().get_first_node_in_group("player")

# 通过Player.gd的适配器接口使用（推荐，向后兼容）
player.add_key("red_key")
player.try_equip_weapon("iron_sword", "Iron Sword", 15)

# 直接访问系统（高级用法）
player.inventory_system.add_key("blue_key")
player.weapon_system.switch_to_next_weapon()
```

### 连接系统信号

```gdscript
# 在UI脚本中连接信号
func _ready():
    var player = get_tree().get_first_node_in_group("player")
    if player:
        player.inventory_system.inventory_changed.connect(_on_inventory_changed)
        player.weapon_system.weapon_changed.connect(_on_weapon_changed)

func _on_inventory_changed():
    update_inventory_display()

func _on_weapon_changed(weapon: WeaponData):
    update_weapon_display(weapon)
```

## 场景结构变化

Player.tscn 的基本结构保持不变，但在运行时会动态创建系统节点：

**静态结构：**
```
Player (CharacterBody2D)
├── PlayerAnimatedSprite (AnimatedSprite2D)
├── PlayerBodyCollision (CollisionShape2D)
├── Camera2D
└── AttackHitbox (Area2D)
    └── CollisionShape2D
```

**运行时动态添加：**
```
Player (CharacterBody2D)
├── ... (上述静态节点)
├── InventorySystem (Node) [动态创建]
└── WeaponSystem (Node) [动态创建]
```

## 优势

1. **职责分离**：每个系统都有明确的职责
2. **易于测试**：可以独立测试各个系统
3. **可维护性**：代码更加模块化，易于修改和扩展
4. **可重用性**：系统可以在其他场景中重用
5. **向后兼容**：现有代码无需修改即可继续工作

## 迁移建议

虽然重构保持了向后兼容性，但建议逐步迁移到新的系统架构：

1. **新功能开发**：直接使用系统组件的接口
2. **现有代码维护**：逐步将直接调用Player.gd的代码改为使用系统组件
3. **信号连接**：优先连接系统级别的信号而不是Player的信号

这样的架构使得代码更加清晰，易于维护和扩展，为未来的功能开发奠定了良好的基础。

## 重要修复

### UI访问问题修复
在重构过程中，发现UI系统（如InventoryPanel.gd）直接访问了Player中的私有属性（如`current_weapon_index`），这些属性在重构后被移动到了系统组件中。

**修复方法：**
```gdscript
# 修复前（会报错）
var current_weapon_index = player_reference.current_weapon_index

# 修复后（通过系统获取）
var current_weapon_index = -1
if player_reference.weapon_system:
    current_weapon_index = player_reference.weapon_system.get_current_weapon_index()
else:
    # 向后兼容的查找方法
    if current_weapon:
        for i in range(weapons.size()):
            if weapons[i].weapon_id == current_weapon.weapon_id:
                current_weapon_index = i
                break
```

这确保了UI能够正确访问系统数据，同时保持了良好的封装性。 